{
"version": 3,
"file": "popper.min.js",
"sources": [
"../../src/utils/isFunction.js",
"../../src/utils/getStyleComputedProperty.js",
"../../src/utils/getParentNode.js",
"../../src/utils/getScrollParent.js",
"../../src/utils/getReferenceNode.js",
"../../src/utils/isIE.js",
"../../src/utils/getOffsetParent.js",
"../../src/utils/isOffsetContainer.js",
"../../src/utils/getRoot.js",
"../../src/utils/findCommonOffsetParent.js",
"../../src/utils/getScroll.js",
"../../src/utils/includeScroll.js",
"../../src/utils/getBordersSize.js",
"../../src/utils/getWindowSizes.js",
"../../src/utils/getClientRect.js",
"../../src/utils/getBoundingClientRect.js",
"../../src/utils/getOffsetRectRelativeToArbitraryNode.js",
"../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js",
"../../src/utils/isFixed.js",
"../../src/utils/getFixedPositionOffsetParent.js",
"../../src/utils/getBoundaries.js",
"../../src/utils/computeAutoPlacement.js",
"../../src/utils/getReferenceOffsets.js",
"../../src/utils/getOuterSizes.js",
"../../src/utils/getOppositePlacement.js",
"../../src/utils/getPopperOffsets.js",
"../../src/utils/find.js",
"../../src/utils/findIndex.js",
"../../src/utils/runModifiers.js",
"../../src/methods/update.js",
"../../src/utils/isModifierEnabled.js",
"../../src/utils/getSupportedPropertyName.js",
"../../src/methods/destroy.js",
"../../src/utils/getWindow.js",
"../../src/utils/setupEventListeners.js",
"../../src/methods/enableEventListeners.js",
"../../src/utils/removeEventListeners.js",
"../../src/methods/disableEventListeners.js",
"../../src/utils/isNumeric.js",
"../../src/utils/setStyles.js",
"../../src/utils/setAttributes.js",
"../../src/utils/getRoundedOffsets.js",
"../../src/utils/isModifierRequired.js",
"../../src/utils/getOppositeVariation.js",
"../../src/utils/clockwise.js",
"../../src/modifiers/offset.js",
"../../src/modifiers/arrow.js",
"../../src/utils/isBrowser.js",
"../../src/utils/debounce.js",
"../../src/modifiers/computeStyle.js",
"../../src/modifiers/flip.js",
"../../src/index.js",
"../../src/methods/defaults.js",
"../../src/modifiers/index.js",
"../../src/modifiers/shift.js",
"../../src/modifiers/preventOverflow.js",
"../../src/modifiers/keepTogether.js",
"../../src/modifiers/inner.js",
"../../src/modifiers/hide.js",
"../../src/modifiers/applyStyle.js"
],
"sourcesContent": [
"/** * Check if the given variable is a function * @method * @memberof Popper.Utils * @argument {Any} functionToCheck - variable to check * @returns {Boolean} answer to: is a function? */ export default function isFunction(functionToCheck) { const getType = {}; return ( functionToCheck && getType.toString.call(functionToCheck) === '[object Function]' ); } ",
"/** * Get CSS computed property of the given element * @method * @memberof Popper.Utils * @argument {Eement} element * @argument {String} property */ export default function getStyleComputedProperty(element, property) { if (element.nodeType !== 1) { return []; } // NOTE: 1 DOM access here const window = element.ownerDocument.defaultView; const css = window.getComputedStyle(element, null); return property ? css[property] : css; } ",
"/** * Returns the parentNode or the host of the element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} parent */ export default function getParentNode(element) { if (element.nodeName === 'HTML') { return element; } return element.parentNode || element.host; } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import getParentNode from './getParentNode'; /** * Returns the scrolling parent of the given element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} scroll parent */ export default function getScrollParent(element) { // Return body, `getScroll` will take care to get the correct `scrollTop` from it if (!element) { return document.body } switch (element.nodeName) { case 'HTML': case 'BODY': return element.ownerDocument.body case '#document': return element.body } // Firefox want us to check `-x` and `-y` variations as well const { overflow, overflowX, overflowY } = getStyleComputedProperty(element); if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) { return element; } return getScrollParent(getParentNode(element)); } ",
"/** * Returns the reference node of the reference object, or the reference object itself. * @method * @memberof Popper.Utils * @param {Element|Object} reference - the reference element (the popper will be relative to this) * @returns {Element} parent */ export default function getReferenceNode(reference) { return reference && reference.referenceNode ? reference.referenceNode : reference; } ",
"import isBrowser from './isBrowser'; const isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode); const isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent); /** * Determines if the browser is Internet Explorer * @method * @memberof Popper.Utils * @param {Number} version to check * @returns {Boolean} isIE */ export default function isIE(version) { if (version === 11) { return isIE11; } if (version === 10) { return isIE10; } return isIE11 || isIE10; } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import isIE from './isIE'; /** * Returns the offset parent of the given element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} offset parent */ export default function getOffsetParent(element) { if (!element) { return document.documentElement; } const noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here let offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent while (offsetParent === noOffsetParent && element.nextElementSibling) { offsetParent = (element = element.nextElementSibling).offsetParent; } const nodeName = offsetParent && offsetParent.nodeName; if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') { return element ? element.ownerDocument.documentElement : document.documentElement; } // .offsetParent will return the closest TH, TD or TABLE in case // no offsetParent is present, I hate this job... if ( ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static' ) { return getOffsetParent(offsetParent); } return offsetParent; } ",
"import getOffsetParent from './getOffsetParent'; export default function isOffsetContainer(element) { const { nodeName } = element; if (nodeName === 'BODY') { return false; } return ( nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element ); } ",
"/** * Finds the root node (document, shadowDOM root) of the given element * @method * @memberof Popper.Utils * @argument {Element} node * @returns {Element} root node */ export default function getRoot(node) { if (node.parentNode !== null) { return getRoot(node.parentNode); } return node; } ",
"import isOffsetContainer from './isOffsetContainer'; import getRoot from './getRoot'; import getOffsetParent from './getOffsetParent'; /** * Finds the offset parent common to the two provided nodes * @method * @memberof Popper.Utils * @argument {Element} element1 * @argument {Element} element2 * @returns {Element} common offset parent */ export default function findCommonOffsetParent(element1, element2) { // This check is needed to avoid errors in case one of the elements isn't defined for any reason if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) { return document.documentElement; } // Here we make sure to give as "start" the element that comes first in the DOM const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING; const start = order ? element1 : element2; const end = order ? element2 : element1; // Get common ancestor container const range = document.createRange(); range.setStart(start, 0); range.setEnd(end, 0); const { commonAncestorContainer } = range; // Both nodes are inside #document if ( (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer) || start.contains(end) ) { if (isOffsetContainer(commonAncestorContainer)) { return commonAncestorContainer; } return getOffsetParent(commonAncestorContainer); } // one of the nodes is inside shadowDOM, find which one const element1root = getRoot(element1); if (element1root.host) { return findCommonOffsetParent(element1root.host, element2); } else { return findCommonOffsetParent(element1, getRoot(element2).host); } } ",
"/** * Gets the scroll value of the given element in the given side (top and left) * @method * @memberof Popper.Utils * @argument {Element} element * @argument {String} side `top` or `left` * @returns {number} amount of scrolled pixels */ export default function getScroll(element, side = 'top') { const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft'; const nodeName = element.nodeName; if (nodeName === 'BODY' || nodeName === 'HTML') { const html = element.ownerDocument.documentElement; const scrollingElement = element.ownerDocument.scrollingElement || html; return scrollingElement[upperSide]; } return element[upperSide]; } ",
"import getScroll from './getScroll'; /* * Sum or subtract the element scroll values (left and top) from a given rect object * @method * @memberof Popper.Utils * @param {Object} rect - Rect object you want to change * @param {HTMLElement} element - The element from the function reads the scroll values * @param {Boolean} subtract - set to true if you want to subtract the scroll values * @return {Object} rect - The modifier rect object */ export default function includeScroll(rect, element, subtract = false) { const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); const modifier = subtract ? -1 : 1; rect.top += scrollTop * modifier; rect.bottom += scrollTop * modifier; rect.left += scrollLeft * modifier; rect.right += scrollLeft * modifier; return rect; } ",
"/* * Helper to detect borders of a given element * @method * @memberof Popper.Utils * @param {CSSStyleDeclaration} styles * Result of `getStyleComputedProperty` on the given element * @param {String} axis - `x` or `y` * @return {number} borders - The borders size of the given axis */ export default function getBordersSize(styles, axis) { const sideA = axis === 'x' ? 'Left' : 'Top'; const sideB = sideA === 'Left' ? 'Right' : 'Bottom'; return ( parseFloat(styles[`border${sideA}Width`], 10) + parseFloat(styles[`border${sideB}Width`], 10) ); } ",
"import isIE from './isIE'; function getSize(axis, body, html, computedStyle) { return Math.max( body[`offset${axis}`], body[`scroll${axis}`], html[`client${axis}`], html[`offset${axis}`], html[`scroll${axis}`], isIE(10) ? (parseInt(html[`offset${axis}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`])) : 0 ); } export default function getWindowSizes(document) { const body = document.body; const html = document.documentElement; const computedStyle = isIE(10) && getComputedStyle(html); return { height: getSize('Height', body, html, computedStyle), width: getSize('Width', body, html, computedStyle), }; } ",
"/** * Given element offsets, generate an output similar to getBoundingClientRect * @method * @memberof Popper.Utils * @argument {Object} offsets * @returns {Object} ClientRect like output */ export default function getClientRect(offsets) { return { ...offsets, right: offsets.left + offsets.width, bottom: offsets.top + offsets.height, }; } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import getBordersSize from './getBordersSize'; import getWindowSizes from './getWindowSizes'; import getScroll from './getScroll'; import getClientRect from './getClientRect'; import isIE from './isIE'; /** * Get bounding client rect of given element * @method * @memberof Popper.Utils * @param {HTMLElement} element * @return {Object} client rect */ export default function getBoundingClientRect(element) { let rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't // considered in DOM in some circumstances... // This isn't reproducible in IE10 compatibility mode of IE11 try { if (isIE(10)) { rect = element.getBoundingClientRect(); const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); rect.top += scrollTop; rect.left += scrollLeft; rect.bottom += scrollTop; rect.right += scrollLeft; } else { rect = element.getBoundingClientRect(); } } catch(e){} const result = { left: rect.left, top: rect.top, width: rect.right - rect.left, height: rect.bottom - rect.top, }; // subtract scrollbar size from sizes const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {}; const width = sizes.width || element.clientWidth || result.width; const height = sizes.height || element.clientHeight || result.height; let horizScrollbar = element.offsetWidth - width; let vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border` // we make this check conditional for performance reasons if (horizScrollbar || vertScrollbar) { const styles = getStyleComputedProperty(element); horizScrollbar -= getBordersSize(styles, 'x'); vertScrollbar -= getBordersSize(styles, 'y'); result.width -= horizScrollbar; result.height -= vertScrollbar; } return getClientRect(result); } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import includeScroll from './includeScroll'; import getScrollParent from './getScrollParent'; import getBoundingClientRect from './getBoundingClientRect'; import runIsIE from './isIE'; import getClientRect from './getClientRect'; export default function getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) { const isIE10 = runIsIE(10); const isHTML = parent.nodeName === 'HTML'; const childrenRect = getBoundingClientRect(children); const parentRect = getBoundingClientRect(parent); const scrollParent = getScrollParent(children); const styles = getStyleComputedProperty(parent); const borderTopWidth = parseFloat(styles.borderTopWidth, 10); const borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); // In cases where the parent is fixed, we must ignore negative scroll in offset calc if(fixedPosition && isHTML) { parentRect.top = Math.max(parentRect.top, 0); parentRect.left = Math.max(parentRect.left, 0); } let offsets = getClientRect({ top: childrenRect.top - parentRect.top - borderTopWidth, left: childrenRect.left - parentRect.left - borderLeftWidth, width: childrenRect.width, height: childrenRect.height, }); offsets.marginTop = 0; offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent // we do this only on HTML because it's the only element that behaves // differently when margins are applied to it. The margins are included in // the box of the documentElement, in the other cases not. if (!isIE10 && isHTML) { const marginTop = parseFloat(styles.marginTop, 10); const marginLeft = parseFloat(styles.marginLeft, 10); offsets.top -= borderTopWidth - marginTop; offsets.bottom -= borderTopWidth - marginTop; offsets.left -= borderLeftWidth - marginLeft; offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them offsets.marginTop = marginTop; offsets.marginLeft = marginLeft; } if ( isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY' ) { offsets = includeScroll(offsets, parent); } return offsets; } ",
"import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getScroll from './getScroll'; import getClientRect from './getClientRect'; export default function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) { const html = element.ownerDocument.documentElement; const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html); const width = Math.max(html.clientWidth, window.innerWidth || 0); const height = Math.max(html.clientHeight, window.innerHeight || 0); const scrollTop = !excludeScroll ? getScroll(html) : 0; const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0; const offset = { top: scrollTop - relativeOffset.top + relativeOffset.marginTop, left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft, width, height, }; return getClientRect(offset); } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import getParentNode from './getParentNode'; /** * Check if the given element is fixed or is inside a fixed parent * @method * @memberof Popper.Utils * @argument {Element} element * @argument {Element} customContainer * @returns {Boolean} answer to "isFixed?" */ export default function isFixed(element) { const nodeName = element.nodeName; if (nodeName === 'BODY' || nodeName === 'HTML') { return false; } if (getStyleComputedProperty(element, 'position') === 'fixed') { return true; } const parentNode = getParentNode(element); if (!parentNode) { return false; } return isFixed(parentNode); } ",
"import getStyleComputedProperty from './getStyleComputedProperty'; import isIE from './isIE'; /** * Finds the first parent of an element that has a transformed property defined * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} first transformed parent or documentElement */ export default function getFixedPositionOffsetParent(element) { // This check is needed to avoid errors in case one of the elements isn't defined for any reason if (!element || !element.parentElement || isIE()) { return document.documentElement; } let el = element.parentElement; while (el && getStyleComputedProperty(el, 'transform') === 'none') { el = el.parentElement; } return el || document.documentElement; } ",
"import getScrollParent from './getScrollParent'; import getParentNode from './getParentNode'; import getReferenceNode from './getReferenceNode'; import findCommonOffsetParent from './findCommonOffsetParent'; import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getViewportOffsetRectRelativeToArtbitraryNode from './getViewportOffsetRectRelativeToArtbitraryNode'; import getWindowSizes from './getWindowSizes'; import isFixed from './isFixed'; import getFixedPositionOffsetParent from './getFixedPositionOffsetParent'; /** * Computed the boundaries limits and return them * @method * @memberof Popper.Utils * @param {HTMLElement} popper * @param {HTMLElement} reference * @param {number} padding * @param {HTMLElement} boundariesElement - Element used to define the boundaries * @param {Boolean} fixedPosition - Is in fixed position mode * @returns {Object} Coordinates of the boundaries */ export default function getBoundaries( popper, reference, padding, boundariesElement, fixedPosition = false ) { // NOTE: 1 DOM access here let boundaries = { top: 0, left: 0 }; const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case if (boundariesElement === 'viewport' ) { boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition); } else { // Handle other cases based on DOM element used as boundaries let boundariesNode; if (boundariesElement === 'scrollParent') { boundariesNode = getScrollParent(getParentNode(reference)); if (boundariesNode.nodeName === 'BODY') { boundariesNode = popper.ownerDocument.documentElement; } } else if (boundariesElement === 'window') { boundariesNode = popper.ownerDocument.documentElement; } else { boundariesNode = boundariesElement; } const offsets = getOffsetRectRelativeToArbitraryNode( boundariesNode, offsetParent, fixedPosition ); // In case of HTML, we need a different computation if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) { const { height, width } = getWindowSizes(popper.ownerDocument); boundaries.top += offsets.top - offsets.marginTop; boundaries.bottom = height + offsets.top; boundaries.left += offsets.left - offsets.marginLeft; boundaries.right = width + offsets.left; } else { // for all the other DOM elements, this one is good boundaries = offsets; } } // Add paddings padding = padding || 0; const isPaddingNumber = typeof padding === 'number'; boundaries.left += isPaddingNumber ? padding : padding.left || 0; boundaries.top += isPaddingNumber ? padding : padding.top || 0; boundaries.right -= isPaddingNumber ? padding : padding.right || 0; boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0; return boundaries; } ",
"import getBoundaries from '../utils/getBoundaries'; function getArea({ width, height }) { return width * height; } /** * Utility used to transform the `auto` placement to the placement with more * available space. * @method * @memberof Popper.Utils * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function computeAutoPlacement( placement, refRect, popper, reference, boundariesElement, padding = 0 ) { if (placement.indexOf('auto') === -1) { return placement; } const boundaries = getBoundaries( popper, reference, padding, boundariesElement ); const rects = { top: { width: boundaries.width, height: refRect.top - boundaries.top, }, right: { width: boundaries.right - refRect.right, height: boundaries.height, }, bottom: { width: boundaries.width, height: boundaries.bottom - refRect.bottom, }, left: { width: refRect.left - boundaries.left, height: boundaries.height, }, }; const sortedAreas = Object.keys(rects) .map(key => ({ key, ...rects[key], area: getArea(rects[key]), })) .sort((a, b) => b.area - a.area); const filteredAreas = sortedAreas.filter( ({ width, height }) => width >= popper.clientWidth && height >= popper.clientHeight ); const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key; const variation = placement.split('-')[1]; return computedPlacement + (variation ? `-${variation}` : ''); } ",
"import findCommonOffsetParent from './findCommonOffsetParent'; import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getFixedPositionOffsetParent from './getFixedPositionOffsetParent'; import getReferenceNode from './getReferenceNode'; /** * Get offsets to the reference element * @method * @memberof Popper.Utils * @param {Object} state * @param {Element} popper - the popper element * @param {Element} reference - the reference element (the popper will be relative to this) * @param {Element} fixedPosition - is in fixed position mode * @returns {Object} An object containing the offsets which will be applied to the popper */ export default function getReferenceOffsets(state, popper, reference, fixedPosition = null) { const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition); } ",
"/** * Get the outer sizes of the given element (offset size + margins) * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Object} object containing width and height properties */ export default function getOuterSizes(element) { const window = element.ownerDocument.defaultView; const styles = window.getComputedStyle(element); const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0); const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0); const result = { width: element.offsetWidth + y, height: element.offsetHeight + x, }; return result; } ",
"/** * Get the opposite placement of the given one * @method * @memberof Popper.Utils * @argument {String} placement * @returns {String} flipped placement */ export default function getOppositePlacement(placement) { const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; return placement.replace(/left|right|bottom|top/g, matched => hash[matched]); } ",
"import getOuterSizes from './getOuterSizes'; import getOppositePlacement from './getOppositePlacement'; /** * Get offsets to the popper * @method * @memberof Popper.Utils * @param {Object} position - CSS position the Popper will get applied * @param {HTMLElement} popper - the popper element * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this) * @param {String} placement - one of the valid placement options * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper */ export default function getPopperOffsets(popper, referenceOffsets, placement) { placement = placement.split('-')[0]; // Get popper node sizes const popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object const popperOffsets = { width: popperRect.width, height: popperRect.height, }; // depending by the popper placement we have to compute its offsets slightly differently const isHoriz = ['right', 'left'].indexOf(placement) !== -1; const mainSide = isHoriz ? 'top' : 'left'; const secondarySide = isHoriz ? 'left' : 'top'; const measurement = isHoriz ? 'height' : 'width'; const secondaryMeasurement = !isHoriz ? 'height' : 'width'; popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2; if (placement === secondarySide) { popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement]; } else { popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)]; } return popperOffsets; } ",
"/** * Mimics the `find` method of Array * @method * @memberof Popper.Utils * @argument {Array} arr * @argument prop * @argument value * @returns index or -1 */ export default function find(arr, check) { // use native find if supported if (Array.prototype.find) { return arr.find(check); } // use `filter` to obtain the same behavior of `find` return arr.filter(check)[0]; } ",
"import find from './find'; /** * Return the index of the matching object * @method * @memberof Popper.Utils * @argument {Array} arr * @argument prop * @argument value * @returns index or -1 */ export default function findIndex(arr, prop, value) { // use native findIndex if supported if (Array.prototype.findIndex) { return arr.findIndex(cur => cur[prop] === value); } // use `find` + `indexOf` if `findIndex` isn't supported const match = find(arr, obj => obj[prop] === value); return arr.indexOf(match); } ",
"import isFunction from './isFunction'; import findIndex from './findIndex'; import getClientRect from '../utils/getClientRect'; /** * Loop trough the list of modifiers and run them in order, * each of them will then edit the data object. * @method * @memberof Popper.Utils * @param {dataObject} data * @param {Array} modifiers * @param {String} ends - Optional modifier name used as stopper * @returns {dataObject} */ export default function runModifiers(modifiers, data, ends) { const modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends)); modifiersToRun.forEach(modifier => { if (modifier['function']) { // eslint-disable-line dot-notation console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); } const fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation if (modifier.enabled && isFunction(fn)) { // Add properties to offsets to make them a complete clientRect object // we do this before each modifier to make sure the previous one doesn't // mess with these values data.offsets.popper = getClientRect(data.offsets.popper); data.offsets.reference = getClientRect(data.offsets.reference); data = fn(data, modifier); } }); return data; } ",
"import computeAutoPlacement from '../utils/computeAutoPlacement'; import getReferenceOffsets from '../utils/getReferenceOffsets'; import getPopperOffsets from '../utils/getPopperOffsets'; import runModifiers from '../utils/runModifiers'; /** * Updates the position of the popper, computing the new offsets and applying * the new style.<br /> * Prefer `scheduleUpdate` over `update` because of performance reasons. * @method * @memberof Popper */ export default function update() { // if popper is destroyed, don't perform any further update if (this.state.isDestroyed) { return; } let data = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: false, offsets: {}, }; // compute reference element offsets data.offsets.reference = getReferenceOffsets( this.state, this.popper, this.reference, this.options.positionFixed ); // compute auto placement, store placement inside the data object, // modifiers will be able to edit `placement` if needed // and refer to originalPlacement to know the original value data.placement = computeAutoPlacement( this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding ); // store the computed placement inside `originalPlacement` data.originalPlacement = data.placement; data.positionFixed = this.options.positionFixed; // compute the popper offsets data.offsets.popper = getPopperOffsets( this.popper, data.offsets.reference, data.placement ); data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback // the other ones will call `onUpdate` callback if (!this.state.isCreated) { this.state.isCreated = true; this.options.onCreate(data); } else { this.options.onUpdate(data); } } ",
"/** * Helper used to know if the given modifier is enabled. * @method * @memberof Popper.Utils * @returns {Boolean} */ export default function isModifierEnabled(modifiers, modifierName) { return modifiers.some( ({ name, enabled }) => enabled && name === modifierName ); } ",
"/** * Get the prefixed supported property name * @method * @memberof Popper.Utils * @argument {String} property (camelCase) * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix) */ export default function getSupportedPropertyName(property) { const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O']; const upperProp = property.charAt(0).toUpperCase() + property.slice(1); for (let i = 0; i < prefixes.length; i++) { const prefix = prefixes[i]; const toCheck = prefix ? `${prefix}${upperProp}` : property; if (typeof document.body.style[toCheck] !== 'undefined') { return toCheck; } } return null; } ",
"import isModifierEnabled from '../utils/isModifierEnabled'; import getSupportedPropertyName from '../utils/getSupportedPropertyName'; /** * Destroys the popper. * @method * @memberof Popper */ export default function destroy() { this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled if (isModifierEnabled(this.modifiers, 'applyStyle')) { this.popper.removeAttribute('x-placement'); this.popper.style.position = ''; this.popper.style.top = ''; this.popper.style.left = ''; this.popper.style.right = ''; this.popper.style.bottom = ''; this.popper.style.willChange = ''; this.popper.style[getSupportedPropertyName('transform')] = ''; } this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy // do not use `remove` because IE11 doesn't support it if (this.options.removeOnDestroy) { this.popper.parentNode.removeChild(this.popper); } return this; } ",
"/** * Get the window associated with the element * @argument {Element} element * @returns {Window} */ export default function getWindow(element) { const ownerDocument = element.ownerDocument; return ownerDocument ? ownerDocument.defaultView : window; } ",
"import getScrollParent from './getScrollParent'; import getWindow from './getWindow'; function attachToScrollParents(scrollParent, event, callback, scrollParents) { const isBody = scrollParent.nodeName === 'BODY'; const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent; target.addEventListener(event, callback, { passive: true }); if (!isBody) { attachToScrollParents( getScrollParent(target.parentNode), event, callback, scrollParents ); } scrollParents.push(target); } /** * Setup needed event listeners used to update the popper position * @method * @memberof Popper.Utils * @private */ export default function setupEventListeners( reference, options, state, updateBound ) { // Resize event listener on window state.updateBound = updateBound; getWindow(reference).addEventListener('resize', state.updateBound, { passive: true }); // Scroll event listener on scroll parents const scrollElement = getScrollParent(reference); attachToScrollParents( scrollElement, 'scroll', state.updateBound, state.scrollParents ); state.scrollElement = scrollElement; state.eventsEnabled = true; return state; } ",
"import setupEventListeners from '../utils/setupEventListeners'; /** * It will add resize/scroll events and start recalculating * position of the popper element when they are triggered. * @method * @memberof Popper */ export default function enableEventListeners() { if (!this.state.eventsEnabled) { this.state = setupEventListeners( this.reference, this.options, this.state, this.scheduleUpdate ); } } ",
"import getWindow from './getWindow'; /** * Remove event listeners used to update the popper position * @method * @memberof Popper.Utils * @private */ export default function removeEventListeners(reference, state) { // Remove resize event listener on window getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents state.scrollParents.forEach(target => { target.removeEventListener('scroll', state.updateBound); }); // Reset state state.updateBound = null; state.scrollParents = []; state.scrollElement = null; state.eventsEnabled = false; return state; } ",
"import removeEventListeners from '../utils/removeEventListeners'; /** * It will remove resize/scroll events and won't recalculate popper position * when they are triggered. It also won't trigger `onUpdate` callback anymore, * unless you call `update` method manually. * @method * @memberof Popper */ export default function disableEventListeners() { if (this.state.eventsEnabled) { cancelAnimationFrame(this.scheduleUpdate); this.state = removeEventListeners(this.reference, this.state); } } ",
"/** * Tells if a given input is a number * @method * @memberof Popper.Utils * @param {*} input to check * @return {Boolean} */ export default function isNumeric(n) { return n !== '' && !isNaN(parseFloat(n)) && isFinite(n); } ",
"import isNumeric from './isNumeric'; /** * Set the style to the given popper * @method * @memberof Popper.Utils * @argument {Element} element - Element to apply the style to * @argument {Object} styles * Object with a list of properties and values which will be applied to the element */ export default function setStyles(element, styles) { Object.keys(styles).forEach(prop => { let unit = ''; // add unit if the value is numeric and is one of the following if ( ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop]) ) { unit = 'px'; } element.style[prop] = styles[prop] + unit; }); } ",
"/** * Set the attributes to the given popper * @method * @memberof Popper.Utils * @argument {Element} element - Element to apply the attributes to * @argument {Object} styles * Object with a list of properties and values which will be applied to the element */ export default function setAttributes(element, attributes) { Object.keys(attributes).forEach(function(prop) { const value = attributes[prop]; if (value !== false) { element.setAttribute(prop, attributes[prop]); } else { element.removeAttribute(prop); } }); } ",
"/** * @function * @memberof Popper.Utils * @argument {Object} data - The data object generated by `update` method * @argument {Boolean} shouldRound - If the offsets should be rounded at all * @returns {Object} The popper's position offsets rounded * * The tale of pixel-perfect positioning. It's still not 100% perfect, but as * good as it can be within reason. * Discussion here: https://github.com/FezVrasta/popper.js/pull/715 * * Low DPI screens cause a popper to be blurry if not using full pixels (Safari * as well on High DPI screens). * * Firefox prefers no rounding for positioning and does not have blurriness on * high DPI screens. * * Only horizontal placement and left/right values need to be considered. */ export default function getRoundedOffsets(data, shouldRound) { const { popper, reference } = data.offsets; const { round, floor } = Math; const noRound = v => v; const referenceWidth = round(reference.width); const popperWidth = round(popper.width); const isVertical = ['left', 'right'].indexOf(data.placement) !== -1; const isVariation = data.placement.indexOf('-') !== -1; const sameWidthParity = referenceWidth % 2 === popperWidth % 2; const bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1; const horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor; const verticalToInteger = !shouldRound ? noRound : round; return { left: horizontalToInteger( bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left ), top: verticalToInteger(popper.top), bottom: verticalToInteger(popper.bottom), right: horizontalToInteger(popper.right), }; } ",
"import find from './find'; /** * Helper used to know if the given modifier depends from another one.<br /> * It checks if the needed modifier is listed and enabled. * @method * @memberof Popper.Utils * @param {Array} modifiers - list of modifiers * @param {String} requestingName - name of requesting modifier * @param {String} requestedName - name of requested modifier * @returns {Boolean} */ export default function isModifierRequired( modifiers, requestingName, requestedName ) { const requesting = find(modifiers, ({ name }) => name === requestingName); const isRequired = !!requesting && modifiers.some(modifier => { return ( modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order ); }); if (!isRequired) { const requesting = `\`${requestingName}\``; const requested = `\`${requestedName}\``; console.warn( `${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!` ); } return isRequired; } ",
"/** * Get the opposite placement variation of the given one * @method * @memberof Popper.Utils * @argument {String} placement variation * @returns {String} flipped placement variation */ export default function getOppositeVariation(variation) { if (variation === 'end') { return 'start'; } else if (variation === 'start') { return 'end'; } return variation; } ",
"import placements from '../methods/placements'; // Get rid of `auto` `auto-start` and `auto-end` const validPlacements = placements.slice(3); /** * Given an initial placement, returns all the subsequent placements * clockwise (or counter-clockwise). * * @method * @memberof Popper.Utils * @argument {String} placement - A valid placement (it accepts variations) * @argument {Boolean} counter - Set to true to walk the placements counterclockwise * @returns {Array} placements including their variations */ export default function clockwise(placement, counter = false) { const index = validPlacements.indexOf(placement); const arr = validPlacements .slice(index + 1) .concat(validPlacements.slice(0, index)); return counter ? arr.reverse() : arr; } ",
"import isNumeric from '../utils/isNumeric'; import getClientRect from '../utils/getClientRect'; import find from '../utils/find'; /** * Converts a string containing value + unit into a px value number * @function * @memberof {modifiers~offset} * @private * @argument {String} str - Value + unit string * @argument {String} measurement - `height` or `width` * @argument {Object} popperOffsets * @argument {Object} referenceOffsets * @returns {Number|String} * Value in pixels, or original string if no values were extracted */ export function toValue(str, measurement, popperOffsets, referenceOffsets) { // separate value from unit const split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const value = +split[1]; const unit = split[2]; // If it's not a number it's an operator, I guess if (!value) { return str; } if (unit.indexOf('%') === 0) { let element; switch (unit) { case '%p': element = popperOffsets; break; case '%': case '%r': default: element = referenceOffsets; } const rect = getClientRect(element); return rect[measurement] / 100 * value; } else if (unit === 'vh' || unit === 'vw') { // if is a vh or vw, we calculate the size based on the viewport let size; if (unit === 'vh') { size = Math.max( document.documentElement.clientHeight, window.innerHeight || 0 ); } else { size = Math.max( document.documentElement.clientWidth, window.innerWidth || 0 ); } return size / 100 * value; } else { // if is an explicit pixel unit, we get rid of the unit and keep the value // if is an implicit unit, it's px, and we return just the value return value; } } /** * Parse an `offset` string to extrapolate `x` and `y` numeric offsets. * @function * @memberof {modifiers~offset} * @private * @argument {String} offset * @argument {Object} popperOffsets * @argument {Object} referenceOffsets * @argument {String} basePlacement * @returns {Array} a two cells array with x and y offsets in numbers */ export function parseOffset( offset, popperOffsets, referenceOffsets, basePlacement ) { const offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width // in this way the first offset will use an axis and the second one // will use the other one const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands // The regex addresses values with the plus or minus sign in front (+10, -20, etc) const fragments = offset.split(/(\+|\-)/).map(frag => frag.trim()); // Detect if the offset string contains a pair of values or a single one // they could be separated by comma or space const divider = fragments.indexOf( find(fragments, frag => frag.search(/,|\s/) !== -1) ); if (fragments[divider] && fragments[divider].indexOf(',') === -1) { console.warn( 'Offsets separated by white space(s) are deprecated, use a comma (,) instead.' ); } // If divider is found, we divide the list of values and operands to divide // them by ofset X and Y. const splitRegex = /\s*,\s*|\s+/; let ops = divider !== -1 ? [ fragments .slice(0, divider) .concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat( fragments.slice(divider + 1) ), ] : [fragments]; // Convert the values with units to absolute pixels to allow our computations ops = ops.map((op, index) => { // Most of the units rely on the orientation of the popper const measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width'; let mergeWithPrevious = false; return ( op // This aggregates any `+` or `-` sign that aren't considered operators // e.g.: 10 + +5 => [10, +, +5] .reduce((a, b) => { if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) { a[a.length - 1] = b; mergeWithPrevious = true; return a; } else if (mergeWithPrevious) { a[a.length - 1] += b; mergeWithPrevious = false; return a; } else { return a.concat(b); } }, []) // Here we convert the string values into number values (in px) .map(str => toValue(str, measurement, popperOffsets, referenceOffsets)) ); }); // Loop trough the offsets arrays and execute the operations ops.forEach((op, index) => { op.forEach((frag, index2) => { if (isNumeric(frag)) { offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1); } }); }); return offsets; } /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @argument {Number|String} options.offset=0 * The offset value as described in the modifier description * @returns {Object} The data object, properly modified */ export default function offset(data, { offset }) { const { placement, offsets: { popper, reference } } = data; const basePlacement = placement.split('-')[0]; let offsets; if (isNumeric(+offset)) { offsets = [+offset, 0]; } else { offsets = parseOffset(offset, popper, reference, basePlacement); } if (basePlacement === 'left') { popper.top += offsets[0]; popper.left -= offsets[1]; } else if (basePlacement === 'right') { popper.top += offsets[0]; popper.left += offsets[1]; } else if (basePlacement === 'top') { popper.left += offsets[0]; popper.top -= offsets[1]; } else if (basePlacement === 'bottom') { popper.left += offsets[0]; popper.top += offsets[1]; } data.popper = popper; return data; } ",
"import getClientRect from '../utils/getClientRect'; import getOuterSizes from '../utils/getOuterSizes'; import isModifierRequired from '../utils/isModifierRequired'; import getStyleComputedProperty from '../utils/getStyleComputedProperty'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function arrow(data, options) { // arrow depends on keepTogether in order to work if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) { return data; } let arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector if (typeof arrowElement === 'string') { arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier if (!arrowElement) { return data; } } else { // if the arrowElement isn't a query selector we must check that the // provided DOM node is child of its popper node if (!data.instance.popper.contains(arrowElement)) { console.warn( 'WARNING: `arrow.element` must be child of its popper element!' ); return data; } } const placement = data.placement.split('-')[0]; const { popper, reference } = data.offsets; const isVertical = ['left', 'right'].indexOf(placement) !== -1; const len = isVertical ? 'height' : 'width'; const sideCapitalized = isVertical ? 'Top' : 'Left'; const side = sideCapitalized.toLowerCase(); const altSide = isVertical ? 'left' : 'top'; const opSide = isVertical ? 'bottom' : 'right'; const arrowElementSize = getOuterSizes(arrowElement)[len]; // // extends keepTogether behavior making sure the popper and its // reference have enough pixels in conjunction // // top/left side if (reference[opSide] - arrowElementSize < popper[side]) { data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize); } // bottom/right side if (reference[side] + arrowElementSize > popper[opSide]) { data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]; } data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper const center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets // take popper margin in account because we don't have this info available const css = getStyleComputedProperty(data.instance.popper); const popperMarginSide = parseFloat(css[`margin${sideCapitalized}`], 10); const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`], 10); let sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0); data.arrowElement = arrowElement; data.offsets.arrow = { [side]: Math.round(sideValue), [altSide]: '', // make sure to unset any eventual altSide value from the DOM node }; return data; } ",
"export default typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'; ",
"import isBrowser from './isBrowser'; const timeoutDuration = (function(){ const longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox']; for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) { if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) { return 1; } } return 0; }()); export function microtaskDebounce(fn) { let called = false return () => { if (called) { return } called = true window.Promise.resolve().then(() => { called = false fn() }) } } export function taskDebounce(fn) { let scheduled = false; return () => { if (!scheduled) { scheduled = true; setTimeout(() => { scheduled = false; fn(); }, timeoutDuration); } }; } const supportsMicroTasks = isBrowser && window.Promise /** * Create a debounced version of a method, that's asynchronously deferred * but called in the minimum time possible. * * @method * @memberof Popper.Utils * @argument {Function} fn * @returns {Function} */ export default (supportsMicroTasks ? microtaskDebounce : taskDebounce); ",
"import getSupportedPropertyName from '../utils/getSupportedPropertyName'; import find from '../utils/find'; import getOffsetParent from '../utils/getOffsetParent'; import getBoundingClientRect from '../utils/getBoundingClientRect'; import getRoundedOffsets from '../utils/getRoundedOffsets'; import isBrowser from '../utils/isBrowser'; const isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent); /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function computeStyle(data, options) { const { x, y } = options; const { popper } = data.offsets; // Remove this legacy support in Popper.js v2 const legacyGpuAccelerationOption = find( data.instance.modifiers, modifier => modifier.name === 'applyStyle' ).gpuAcceleration; if (legacyGpuAccelerationOption !== undefined) { console.warn( 'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!' ); } const gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration; const offsetParent = getOffsetParent(data.instance.popper); const offsetParentRect = getBoundingClientRect(offsetParent); // Styles const styles = { position: popper.position, }; const offsets = getRoundedOffsets( data, window.devicePixelRatio < 2 || !isFirefox ); const sideA = x === 'bottom' ? 'top' : 'bottom'; const sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported, // we use `translate3d` to apply the position to the popper we // automatically use the supported prefixed version if needed const prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?) // If the content of the popper grows once it's been positioned, it // may happen that the popper gets misplaced because of the new content // overflowing its reference element // To avoid this problem, we provide two options (x and y), which allow // the consumer to define the offset origin. // If we position a popper on top of a reference element, we can set // `x` to `top` to make the popper grow towards its top instead of // its bottom. let left, top; if (sideA === 'bottom') { // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar) // and not the bottom of the html element if (offsetParent.nodeName === 'HTML') { top = -offsetParent.clientHeight + offsets.bottom; } else { top = -offsetParentRect.height + offsets.bottom; } } else { top = offsets.top; } if (sideB === 'right') { if (offsetParent.nodeName === 'HTML') { left = -offsetParent.clientWidth + offsets.right; } else { left = -offsetParentRect.width + offsets.right; } } else { left = offsets.left; } if (gpuAcceleration && prefixedProperty) { styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`; styles[sideA] = 0; styles[sideB] = 0; styles.willChange = 'transform'; } else { // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties const invertTop = sideA === 'bottom' ? -1 : 1; const invertLeft = sideB === 'right' ? -1 : 1; styles[sideA] = top * invertTop; styles[sideB] = left * invertLeft; styles.willChange = `${sideA}, ${sideB}`; } // Attributes const attributes = { 'x-placement': data.placement, }; // Update `data` attributes, styles and arrowStyles data.attributes = { ...attributes, ...data.attributes }; data.styles = { ...styles, ...data.styles }; data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles }; return data; } ",
"import getOppositePlacement from '../utils/getOppositePlacement'; import getOppositeVariation from '../utils/getOppositeVariation'; import getPopperOffsets from '../utils/getPopperOffsets'; import runModifiers from '../utils/runModifiers'; import getBoundaries from '../utils/getBoundaries'; import isModifierEnabled from '../utils/isModifierEnabled'; import clockwise from '../utils/clockwise'; const BEHAVIORS = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise', }; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function flip(data, options) { // if `inner` modifier is enabled, we can't use the `flip` modifier if (isModifierEnabled(data.instance.modifiers, 'inner')) { return data; } if (data.flipped && data.placement === data.originalPlacement) { // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides return data; } const boundaries = getBoundaries( data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed ); let placement = data.placement.split('-')[0]; let placementOpposite = getOppositePlacement(placement); let variation = data.placement.split('-')[1] || ''; let flipOrder = []; switch (options.behavior) { case BEHAVIORS.FLIP: flipOrder = [placement, placementOpposite]; break; case BEHAVIORS.CLOCKWISE: flipOrder = clockwise(placement); break; case BEHAVIORS.COUNTERCLOCKWISE: flipOrder = clockwise(placement, true); break; default: flipOrder = options.behavior; } flipOrder.forEach((step, index) => { if (placement !== step || flipOrder.length === index + 1) { return data; } placement = data.placement.split('-')[0]; placementOpposite = getOppositePlacement(placement); const popperOffsets = data.offsets.popper; const refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here const floor = Math.floor; const overlapsRef = (placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left)) || (placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right)) || (placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top)) || (placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom)); const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left); const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right); const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top); const overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom); const overflowsBoundaries = (placement === 'left' && overflowsLeft) || (placement === 'right' && overflowsRight) || (placement === 'top' && overflowsTop) || (placement === 'bottom' && overflowsBottom); // flip the variation if required const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries const flippedVariationByRef = !!options.flipVariations && ((isVertical && variation === 'start' && overflowsLeft) || (isVertical && variation === 'end' && overflowsRight) || (!isVertical && variation === 'start' && overflowsTop) || (!isVertical && variation === 'end' && overflowsBottom)); // flips variation if popper content overflows boundaries const flippedVariationByContent = !!options.flipVariationsByContent && ((isVertical && variation === 'start' && overflowsRight) || (isVertical && variation === 'end' && overflowsLeft) || (!isVertical && variation === 'start' && overflowsBottom) || (!isVertical && variation === 'end' && overflowsTop)); const flippedVariation = flippedVariationByRef || flippedVariationByContent; if (overlapsRef || overflowsBoundaries || flippedVariation) { // this boolean to detect any flip loop data.flipped = true; if (overlapsRef || overflowsBoundaries) { placement = flipOrder[index + 1]; } if (flippedVariation) { variation = getOppositeVariation(variation); } data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with // any additional property we may add in the future data.offsets.popper = { ...data.offsets.popper, ...getPopperOffsets( data.instance.popper, data.offsets.reference, data.placement ), }; data = runModifiers(data.instance.modifiers, data, 'flip'); } }); return data; } ",
"// Utils import debounce from './utils/debounce'; import isFunction from './utils/isFunction'; // Methods import update from './methods/update'; import destroy from './methods/destroy'; import enableEventListeners from './methods/enableEventListeners'; import disableEventListeners from './methods/disableEventListeners'; import Defaults from './methods/defaults'; import placements from './methods/placements'; export default class Popper { /** * Creates a new Popper.js instance. * @class Popper * @param {Element|referenceObject} reference - The reference element used to position the popper * @param {Element} popper - The HTML / XML element used as the popper * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults) * @return {Object} instance - The generated Popper.js instance */ constructor(reference, popper, options = {}) { // make update() debounced, so that it only runs at most once-per-tick this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it this.options = { ...Popper.Defaults, ...options }; // init state this.state = { isDestroyed: false, isCreated: false, scrollParents: [], }; // get reference and popper elements (allow jQuery wrappers) this.reference = reference && reference.jquery ? reference[0] : reference; this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options this.options.modifiers = {}; Object.keys({ ...Popper.Defaults.modifiers, ...options.modifiers, }).forEach(name => { this.options.modifiers[name] = { // If it's a built-in modifier, use it as base ...(Popper.Defaults.modifiers[name] || {}), // If there are custom options, override and merge with default ones ...(options.modifiers ? options.modifiers[name] : {}), }; }); // Refactoring modifiers' list (Object => Array) this.modifiers = Object.keys(this.options.modifiers) .map(name => ({ name, ...this.options.modifiers[name], })) // sort the modifiers by order .sort((a, b) => a.order - b.order); // modifiers have the ability to execute arbitrary code when Popper.js get inited // such code is executed in the same order of its modifier // they could add new properties to their options configuration // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`! this.modifiers.forEach(modifierOptions => { if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) { modifierOptions.onLoad( this.reference, this.popper, this.options, modifierOptions, this.state ); } }); // fire the first update to position the popper in the right place this.update(); const eventsEnabled = this.options.eventsEnabled; if (eventsEnabled) { // setup event listeners, they will take care of update the position in specific situations this.enableEventListeners(); } this.state.eventsEnabled = eventsEnabled; } // We can't use class properties because they don't get listed in the // class prototype and break stuff like Sinon stubs update() { return update.call(this); } destroy() { return destroy.call(this); } enableEventListeners() { return enableEventListeners.call(this); } disableEventListeners() { return disableEventListeners.call(this); } /** * Schedules an update. It will run on the next UI update available. * @method scheduleUpdate * @memberof Popper */ scheduleUpdate = () => requestAnimationFrame(this.update); /** * Collection of utilities useful when writing custom modifiers. * Starting from version 1.7, this method is available only if you * include `popper-utils.js` before `popper.js`. * * **DEPRECATION**: This way to access PopperUtils is deprecated * and will be removed in v2! Use the PopperUtils module directly instead. * Due to the high instability of the methods contained in Utils, we can't * guarantee them to follow semver. Use them at your own risk! * @static * @private * @type {Object} * @deprecated since version 1.8 * @member Utils * @memberof Popper */ static Utils = (typeof window !== 'undefined' ? window : global).PopperUtils; static placements = placements; static Defaults = Defaults; } /** * The `referenceObject` is an object that provides an interface compatible with Popper.js * and lets you use it as replacement of a real DOM node.<br /> * You can use this method to position a popper relatively to a set of coordinates * in case you don't have a DOM node to use as reference. * * ``` * new Popper(referenceObject, popperNode); * ``` * * NB: This feature isn't supported in Internet Explorer 10. * @name referenceObject * @property {Function} data.getBoundingClientRect * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method. * @property {number} data.clientWidth * An ES6 getter that will return the width of the virtual reference element. * @property {number} data.clientHeight * An ES6 getter that will return the height of the virtual reference element. */ ",
"import modifiers from '../modifiers/index'; /** * Default options provided to Popper.js constructor.<br /> * These can be overridden using the `options` argument of Popper.js.<br /> * To override an option, simply pass an object with the same * structure of the `options` object, as the 3rd argument. For example: * ``` * new Popper(ref, pop, { * modifiers: { * preventOverflow: { enabled: false } * } * }) * ``` * @type {Object} * @static * @memberof Popper */ export default { /** * Popper's placement. * @prop {Popper.placements} placement='bottom' */ placement: 'bottom', /** * Set this to true if you want popper to position it self in 'fixed' mode * @prop {Boolean} positionFixed=false */ positionFixed: false, /** * Whether events (resize, scroll) are initially enabled. * @prop {Boolean} eventsEnabled=true */ eventsEnabled: true, /** * Set to true if you want to automatically remove the popper when * you call the `destroy` method. * @prop {Boolean} removeOnDestroy=false */ removeOnDestroy: false, /** * Callback called when the popper is created.<br /> * By default, it is set to no-op.<br /> * Access Popper.js instance with `data.instance`. * @prop {onCreate} */ onCreate: () => {}, /** * Callback called when the popper is updated. This callback is not called * on the initialization/creation of the popper, but only on subsequent * updates.<br /> * By default, it is set to no-op.<br /> * Access Popper.js instance with `data.instance`. * @prop {onUpdate} */ onUpdate: () => {}, /** * List of modifiers used to modify the offsets before they are applied to the popper. * They provide most of the functionalities of Popper.js. * @prop {modifiers} */ modifiers, }; /** * @callback onCreate * @param {dataObject} data */ /** * @callback onUpdate * @param {dataObject} data */ ",
"import applyStyle, { applyStyleOnLoad } from './applyStyle'; import computeStyle from './computeStyle'; import arrow from './arrow'; import flip from './flip'; import keepTogether from './keepTogether'; import offset from './offset'; import preventOverflow from './preventOverflow'; import shift from './shift'; import hide from './hide'; import inner from './inner'; /** * Modifier function, each modifier can have a function of this type assigned * to its `fn` property.<br /> * These functions will be called on each update, this means that you must * make sure they are performant enough to avoid performance bottlenecks. * * @function ModifierFn * @argument {dataObject} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {dataObject} The data object, properly modified */ /** * Modifiers are plugins used to alter the behavior of your poppers.<br /> * Popper.js uses a set of 9 modifiers to provide all the basic functionalities * needed by the library. * * Usually you don't want to override the `order`, `fn` and `onLoad` props. * All the other properties are configurations that could be tweaked. * @namespace modifiers */ export default { /** * Modifier used to shift the popper on the start or end of its reference * element.<br /> * It will read the variation of the `placement` property.<br /> * It can be one either `-end` or `-start`. * @memberof modifiers * @inner */ shift: { /** @prop {number} order=100 - Index used to define the order of execution */ order: 100, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: shift, }, /** * The `offset` modifier can shift your popper on both its axis. * * It accepts the following units: * - `px` or unit-less, interpreted as pixels * - `%` or `%r`, percentage relative to the length of the reference element * - `%p`, percentage relative to the length of the popper element * - `vw`, CSS viewport width unit * - `vh`, CSS viewport height unit * * For length is intended the main axis relative to the placement of the popper.<br /> * This means that if the placement is `top` or `bottom`, the length will be the * `width`. In case of `left` or `right`, it will be the `height`. * * You can provide a single value (as `Number` or `String`), or a pair of values * as `String` divided by a comma or one (or more) white spaces.<br /> * The latter is a deprecated method because it leads to confusion and will be * removed in v2.<br /> * Additionally, it accepts additions and subtractions between different units. * Note that multiplications and divisions aren't supported. * * Valid examples are: * ``` * 10 * '10%' * '10, 10' * '10%, 10' * '10 + 10%' * '10 - 5vh + 3%' * '-10px + 5vh, 5px - 6%' * ``` * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap * > with their reference element, unfortunately, you will have to disable the `flip` modifier. * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373). * * @memberof modifiers * @inner */ offset: { /** @prop {number} order=200 - Index used to define the order of execution */ order: 200, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: offset, /** @prop {Number|String} offset=0 * The offset value as described in the modifier description */ offset: 0, }, /** * Modifier used to prevent the popper from being positioned outside the boundary. * * A scenario exists where the reference itself is not within the boundaries.<br /> * We can say it has "escaped the boundaries" — or just "escaped".<br /> * In this case we need to decide whether the popper should either: * * - detach from the reference and remain "trapped" in the boundaries, or * - if it should ignore the boundary and "escape with its reference" * * When `escapeWithReference` is set to`true` and reference is completely * outside its boundaries, the popper will overflow (or completely leave) * the boundaries in order to remain attached to the edge of the reference. * * @memberof modifiers * @inner */ preventOverflow: { /** @prop {number} order=300 - Index used to define the order of execution */ order: 300, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: preventOverflow, /** * @prop {Array} [priority=['left','right','top','bottom']] * Popper will try to prevent overflow following these priorities by default, * then, it could overflow on the left and on top of the `boundariesElement` */ priority: ['left', 'right', 'top', 'bottom'], /** * @prop {number} padding=5 * Amount of pixel used to define a minimum distance between the boundaries * and the popper. This makes sure the popper always has a little padding * between the edges of its container */ padding: 5, /** * @prop {String|HTMLElement} boundariesElement='scrollParent' * Boundaries used by the modifier. Can be `scrollParent`, `window`, * `viewport` or any DOM element. */ boundariesElement: 'scrollParent', }, /** * Modifier used to make sure the reference and its popper stay near each other * without leaving any gap between the two. Especially useful when the arrow is * enabled and you want to ensure that it points to its reference element. * It cares only about the first axis. You can still have poppers with margin * between the popper and its reference element. * @memberof modifiers * @inner */ keepTogether: { /** @prop {number} order=400 - Index used to define the order of execution */ order: 400, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: keepTogether, }, /** * This modifier is used to move the `arrowElement` of the popper to make * sure it is positioned between the reference element and its popper element. * It will read the outer size of the `arrowElement` node to detect how many * pixels of conjunction are needed. * * It has no effect if no `arrowElement` is provided. * @memberof modifiers * @inner */ arrow: { /** @prop {number} order=500 - Index used to define the order of execution */ order: 500, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: arrow, /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */ element: '[x-arrow]', }, /** * Modifier used to flip the popper's placement when it starts to overlap its * reference element. * * Requires the `preventOverflow` modifier before it in order to work. * * **NOTE:** this modifier will interrupt the current update cycle and will * restart it if it detects the need to flip the placement. * @memberof modifiers * @inner */ flip: { /** @prop {number} order=600 - Index used to define the order of execution */ order: 600, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: flip, /** * @prop {String|Array} behavior='flip' * The behavior used to change the popper's placement. It can be one of * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid * placements (with optional variations) */ behavior: 'flip', /** * @prop {number} padding=5 * The popper will flip if it hits the edges of the `boundariesElement` */ padding: 5, /** * @prop {String|HTMLElement} boundariesElement='viewport' * The element which will define the boundaries of the popper position. * The popper will never be placed outside of the defined boundaries * (except if `keepTogether` is enabled) */ boundariesElement: 'viewport', /** * @prop {Boolean} flipVariations=false * The popper will switch placement variation between `-start` and `-end` when * the reference element overlaps its boundaries. * * The original placement should have a set variation. */ flipVariations: false, /** * @prop {Boolean} flipVariationsByContent=false * The popper will switch placement variation between `-start` and `-end` when * the popper element overlaps its reference boundaries. * * The original placement should have a set variation. */ flipVariationsByContent: false, }, /** * Modifier used to make the popper flow toward the inner of the reference element. * By default, when this modifier is disabled, the popper will be placed outside * the reference element. * @memberof modifiers * @inner */ inner: { /** @prop {number} order=700 - Index used to define the order of execution */ order: 700, /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */ enabled: false, /** @prop {ModifierFn} */ fn: inner, }, /** * Modifier used to hide the popper when its reference element is outside of the * popper boundaries. It will set a `x-out-of-boundaries` attribute which can * be used to hide with a CSS selector the popper when its reference is * out of boundaries. * * Requires the `preventOverflow` modifier before it in order to work. * @memberof modifiers * @inner */ hide: { /** @prop {number} order=800 - Index used to define the order of execution */ order: 800, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: hide, }, /** * Computes the style that will be applied to the popper element to gets * properly positioned. * * Note that this modifier will not touch the DOM, it just prepares the styles * so that `applyStyle` modifier can apply it. This separation is useful * in case you need to replace `applyStyle` with a custom implementation. * * This modifier has `850` as `order` value to maintain backward compatibility * with previous versions of Popper.js. Expect the modifiers ordering method * to change in future major versions of the library. * * @memberof modifiers * @inner */ computeStyle: { /** @prop {number} order=850 - Index used to define the order of execution */ order: 850, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: computeStyle, /** * @prop {Boolean} gpuAcceleration=true * If true, it uses the CSS 3D transformation to position the popper. * Otherwise, it will use the `top` and `left` properties */ gpuAcceleration: true, /** * @prop {string} [x='bottom'] * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin. * Change this if your popper should grow in a direction different from `bottom` */ x: 'bottom', /** * @prop {string} [x='left'] * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin. * Change this if your popper should grow in a direction different from `right` */ y: 'right', }, /** * Applies the computed styles to the popper element. * * All the DOM manipulations are limited to this modifier. This is useful in case * you want to integrate Popper.js inside a framework or view library and you * want to delegate all the DOM manipulations to it. * * Note that if you disable this modifier, you must make sure the popper element * has its position set to `absolute` before Popper.js can do its work! * * Just disable this modifier and define your own to achieve the desired effect. * * @memberof modifiers * @inner */ applyStyle: { /** @prop {number} order=900 - Index used to define the order of execution */ order: 900, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: applyStyle, /** @prop {Function} */ onLoad: applyStyleOnLoad, /** * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier * @prop {Boolean} gpuAcceleration=true * If true, it uses the CSS 3D transformation to position the popper. * Otherwise, it will use the `top` and `left` properties */ gpuAcceleration: undefined, }, }; /** * The `dataObject` is an object containing all the information used by Popper.js. * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks. * @name dataObject * @property {Object} data.instance The Popper.js instance * @property {String} data.placement Placement applied to popper * @property {String} data.originalPlacement Placement originally defined on init * @property {Boolean} data.flipped True if popper has been flipped by flip modifier * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`) * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`) * @property {Object} data.boundaries Offsets of the popper boundaries * @property {Object} data.offsets The measurements of popper, reference and arrow elements * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0 */ ",
"/** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function shift(data) { const placement = data.placement; const basePlacement = placement.split('-')[0]; const shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier if (shiftvariation) { const { reference, popper } = data.offsets; const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1; const side = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; const shiftOffsets = { start: { [side]: reference[side] }, end: { [side]: reference[side] + reference[measurement] - popper[measurement], }, }; data.offsets.popper = { ...popper, ...shiftOffsets[shiftvariation] }; } return data; } ",
"import getOffsetParent from '../utils/getOffsetParent'; import getBoundaries from '../utils/getBoundaries'; import getSupportedPropertyName from '../utils/getSupportedPropertyName'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function preventOverflow(data, options) { let boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to // go one step up and use the next offsetParent as reference to // avoid to make this modifier completely useless and look like broken if (data.instance.reference === boundariesElement) { boundariesElement = getOffsetParent(boundariesElement); } // NOTE: DOM access here // resets the popper's position so that the document size can be calculated excluding // the size of the popper element itself const transformProp = getSupportedPropertyName('transform'); const popperStyles = data.instance.popper.style; // assignment to help minification const { top, left, [transformProp]: transform } = popperStyles; popperStyles.top = ''; popperStyles.left = ''; popperStyles[transformProp] = ''; const boundaries = getBoundaries( data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed ); // NOTE: DOM access here // restores the original style properties after the offsets have been computed popperStyles.top = top; popperStyles.left = left; popperStyles[transformProp] = transform; options.boundaries = boundaries; const order = options.priority; let popper = data.offsets.popper; const check = { primary(placement) { let value = popper[placement]; if ( popper[placement] < boundaries[placement] && !options.escapeWithReference ) { value = Math.max(popper[placement], boundaries[placement]); } return { [placement]: value }; }, secondary(placement) { const mainSide = placement === 'right' ? 'left' : 'top'; let value = popper[mainSide]; if ( popper[placement] > boundaries[placement] && !options.escapeWithReference ) { value = Math.min( popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height) ); } return { [mainSide]: value }; }, }; order.forEach(placement => { const side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary'; popper = { ...popper, ...check[side](placement) }; }); data.offsets.popper = popper; return data; } ",
"/** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function keepTogether(data) { const { popper, reference } = data.offsets; const placement = data.placement.split('-')[0]; const floor = Math.floor; const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; const side = isVertical ? 'right' : 'bottom'; const opSide = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; if (popper[side] < floor(reference[opSide])) { data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]; } if (popper[opSide] > floor(reference[side])) { data.offsets.popper[opSide] = floor(reference[side]); } return data; } ",
"import getClientRect from '../utils/getClientRect'; import getOppositePlacement from '../utils/getOppositePlacement'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function inner(data) { const placement = data.placement; const basePlacement = placement.split('-')[0]; const { popper, reference } = data.offsets; const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1; const subtractLength = ['top', 'left'].indexOf(basePlacement) === -1; popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0); data.placement = getOppositePlacement(placement); data.offsets.popper = getClientRect(popper); return data; } ",
"import isModifierRequired from '../utils/isModifierRequired'; import find from '../utils/find'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function hide(data) { if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) { return data; } const refRect = data.offsets.reference; const bound = find( data.instance.modifiers, modifier => modifier.name === 'preventOverflow' ).boundaries; if ( refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left ) { // Avoid unnecessary DOM access if visibility hasn't changed if (data.hide === true) { return data; } data.hide = true; data.attributes['x-out-of-boundaries'] = ''; } else { // Avoid unnecessary DOM access if visibility hasn't changed if (data.hide === false) { return data; } data.hide = false; data.attributes['x-out-of-boundaries'] = false; } return data; } ",
"import setStyles from '../utils/setStyles'; import setAttributes from '../utils/setAttributes'; import getReferenceOffsets from '../utils/getReferenceOffsets'; import computeAutoPlacement from '../utils/computeAutoPlacement'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} data.styles - List of style properties - values to apply to popper element * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element * @argument {Object} options - Modifiers configuration and options * @returns {Object} The same data object */ export default function applyStyle(data) { // any property present in `data.styles` will be applied to the popper, // in this way we can make the 3rd party modifiers add custom styles to it // Be aware, modifiers could override the properties defined in the previous // lines of this modifier! setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper, // they will be set as HTML attributes of the element setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties if (data.arrowElement && Object.keys(data.arrowStyles).length) { setStyles(data.arrowElement, data.arrowStyles); } return data; } /** * Set the x-placement attribute before everything else because it could be used * to add margins to the popper margins needs to be calculated to get the * correct popper offsets. * @method * @memberof Popper.modifiers * @param {HTMLElement} reference - The reference element used to position the popper * @param {HTMLElement} popper - The HTML element used as popper * @param {Object} options - Popper.js options */ export function applyStyleOnLoad( reference, popper, options, modifierOptions, state ) { // compute reference element offsets const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object, // modifiers will be able to edit `placement` if needed // and refer to originalPlacement to know the original value const placement = computeAutoPlacement( options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding ); popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because // without the position applied we can't guarantee correct computations setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' }); return options; } "
],
"names": [
"functionToCheck",
"getType",
"toString",
"call",
"element",
"nodeType",
"window",
"ownerDocument",
"defaultView",
"css",
"getComputedStyle",
"property",
"nodeName",
"parentNode",
"host",
"document",
"body",
"getStyleComputedProperty",
"overflow",
"overflowX",
"overflowY",
"test",
"getScrollParent",
"getParentNode",
"reference",
"referenceNode",
"version",
"isIE11",
"documentElement",
"noOffsetParent",
"isIE",
"offsetParent",
"nextElementSibling",
"indexOf",
"getOffsetParent",
"firstElementChild",
"node",
"getRoot",
"element1",
"element2",
"order",
"compareDocumentPosition",
"Node",
"DOCUMENT_POSITION_FOLLOWING",
"start",
"end",
"range",
"createRange",
"setStart",
"setEnd",
"commonAncestorContainer",
"contains",
"isOffsetContainer",
"element1root",
"findCommonOffsetParent",
"side",
"upperSide",
"html",
"scrollingElement",
"subtract",
"scrollTop",
"getScroll",
"scrollLeft",
"modifier",
"top",
"bottom",
"left",
"right",
"sideA",
"axis",
"sideB",
"parseFloat",
"styles",
"Math",
"parseInt",
"computedStyle",
"getSize",
"offsets",
"width",
"height",
"rect",
"getBoundingClientRect",
"result",
"sizes",
"getWindowSizes",
"clientWidth",
"clientHeight",
"horizScrollbar",
"offsetWidth",
"vertScrollbar",
"offsetHeight",
"getBordersSize",
"getClientRect",
"fixedPosition",
"isIE10",
"runIsIE",
"isHTML",
"parent",
"childrenRect",
"parentRect",
"scrollParent",
"borderTopWidth",
"borderLeftWidth",
"marginTop",
"marginLeft",
"includeScroll",
"excludeScroll",
"relativeOffset",
"getOffsetRectRelativeToArbitraryNode",
"innerWidth",
"innerHeight",
"offset",
"isFixed",
"parentElement",
"el",
"boundaries",
"getFixedPositionOffsetParent",
"getReferenceNode",
"boundariesElement",
"getViewportOffsetRectRelativeToArtbitraryNode",
"boundariesNode",
"popper",
"padding",
"isPaddingNumber",
"placement",
"getBoundaries",
"rects",
"refRect",
"sortedAreas",
"Object",
"keys",
"map",
"getArea",
"sort",
"b",
"area",
"a",
"filteredAreas",
"filter",
"computedPlacement",
"length",
"key",
"variation",
"split",
"commonOffsetParent",
"x",
"marginBottom",
"y",
"marginRight",
"hash",
"replace",
"popperRect",
"getOuterSizes",
"popperOffsets",
"isHoriz",
"mainSide",
"secondarySide",
"measurement",
"secondaryMeasurement",
"referenceOffsets",
"getOppositePlacement",
"Array",
"prototype",
"find",
"arr",
"findIndex",
"cur",
"match",
"obj",
"modifiersToRun",
"ends",
"modifiers",
"slice",
"forEach",
"warn",
"fn",
"enabled",
"isFunction",
"data",
"state",
"isDestroyed",
"getReferenceOffsets",
"options",
"positionFixed",
"computeAutoPlacement",
"flip",
"originalPlacement",
"getPopperOffsets",
"position",
"runModifiers",
"isCreated",
"onUpdate",
"onCreate",
"some",
"name",
"prefixes",
"upperProp",
"charAt",
"toUpperCase",
"i",
"prefix",
"toCheck",
"style",
"isModifierEnabled",
"removeAttribute",
"willChange",
"getSupportedPropertyName",
"disableEventListeners",
"removeOnDestroy",
"removeChild",
"isBody",
"target",
"addEventListener",
"passive",
"push",
"updateBound",
"scrollElement",
"scrollParents",
"eventsEnabled",
"setupEventListeners",
"scheduleUpdate",
"removeEventListener",
"removeEventListeners",
"n",
"isNaN",
"isFinite",
"unit",
"isNumeric",
"value",
"attributes",
"setAttribute",
"round",
"noRound",
"referenceWidth",
"popperWidth",
"isVertical",
"isVariation",
"horizontalToInteger",
"verticalToInteger",
"bothOddWidth",
"requesting",
"isRequired",
"requested",
"counter",
"index",
"validPlacements",
"concat",
"reverse",
"str",
"size",
"useHeight",
"fragments",
"frag",
"trim",
"divider",
"search",
"splitRegex",
"ops",
"mergeWithPrevious",
"op",
"reduce",
"toValue",
"index2",
"basePlacement",
"parseOffset",
"min",
"floor",
"max",
"navigator",
"longerTimeoutBrowsers",
"isBrowser",
"userAgent",
"supportsMicroTasks",
"Promise",
"called",
"resolve",
"then",
"scheduled",
"MSInputMethodContext",
"documentMode",
"isFirefox",
"placements",
"BEHAVIORS",
"Popper",
"requestAnimationFrame",
"update",
"debounce",
"bind",
"Defaults",
"jquery",
"modifierOptions",
"onLoad",
"enableEventListeners",
"destroy",
"Utils",
"global",
"PopperUtils",
"shiftvariation",
"shiftOffsets",
"instance",
"transformProp",
"popperStyles",
"transform",
"priority",
"check",
"escapeWithReference",
"opSide",
"isModifierRequired",
"arrowElement",
"querySelector",
"len",
"sideCapitalized",
"toLowerCase",
"altSide",
"arrowElementSize",
"center",
"popperMarginSide",
"popperBorderSide",
"sideValue",
"arrow",
"flipped",
"placementOpposite",
"flipOrder",
"behavior",
"FLIP",
"CLOCKWISE",
"clockwise",
"COUNTERCLOCKWISE",
"refOffsets",
"overlapsRef",
"overflowsLeft",
"overflowsRight",
"overflowsTop",
"overflowsBottom",
"overflowsBoundaries",
"flippedVariationByRef",
"flipVariations",
"flippedVariationByContent",
"flipVariationsByContent",
"flippedVariation",
"getOppositeVariation",
"subtractLength",
"bound",
"hide",
"legacyGpuAccelerationOption",
"gpuAcceleration",
"offsetParentRect",
"getRoundedOffsets",
"devicePixelRatio",
"prefixedProperty",
"invertTop",
"invertLeft",
"arrowStyles"
],
"mappings": "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"
}